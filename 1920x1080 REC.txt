#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <Windows.h>
#include <GL\glew.h>
#include <GL\freeglut.h>

using namespace std;

#define MAP 1
#define TREE 2
#define ROAD 3
#define KEY_LEGEND 4
#define CHARACTER 5
#define HEDGE_SINGLE 6
//LEVEL 1
#define NODES_1 7
#define HOUSE  8
#define	MESH_SINGLE 9
#define FENCE 10
#define HEDGE_MULTIPLE_1 11
//LEVEL 2
#define NODES_2 15
//CUTSCENE
#define CUTSCENE_BACKGROUND 80


#define BLUE 0
#define YELLOW 1

unsigned char header[54];		// Each BMP file begins by a 54-bytes header
unsigned int dataPos;			// Position in the file where the actual data begins
unsigned int width, height;
unsigned int imageSize;			// = width*height*3
unsigned char * data=NULL;		// Actual RGB data

float i;	//to animate cutscene

// actual vector representing the camera's direction
float lx=0.0f,lz=-1.0f;
// XZ position of the camera
float x=0.0f,z=100.0f;
// angle for rotating triangle
float angle = 0.0f;


enum ActiveScreen{START,LEVEL1,LEVEL2,OBJECTIVES,INSTRUCTIONS,CUTSCENE};
ActiveScreen Screen=CUTSCENE,PreviousScreen=START;
enum direction{LEFT,RIGHT,UP,DOWN};
direction dir;
short int guard_count,yellow_guard_count,node_hold_count[22],current_state,move_counter,objectives_completed_count;
short int move_array[22][4],map_array[22][23],original_map_array[22][23];
bool briefcase_picked_up,objectives_flag[6];

short int move_array_1[17][4]={
{0,2,0,0},
{1,3,0,5},
{2,4,0,6},
{3,0,0,7},
{0,6,2,9},
{5,0,3,10},
{0,0,4,11},
{0,9,0,0},
{8,0,5,12},
{0,11,6,13},
{10,18,7,14},
{0,0,9,15},
{0,0,10,0},
{0,0,11,17},
{0,16,12,0},
{15,17,0,0},
{16,0,14,0},
};
short int move_array_2[22][4]={
{0,2,0,6},
{1,3,0,7},
{2,4,0,0},
{3,0,0,9},
{0,6,23,10},
{5,7,1,11},
{6,8,2,0},
{7,9,0,13},
{8,0,4,14},
{0,11,5,15},
{10,12,6,16},
{11,13,0,0},
{12,0,8,0},
{0,0,9,19},
{0,0,10,0},
{0,17,11,20},
{16,18,0,0},
{17,19,0,22},
{18,0,14,0},
{0,21,16,0},
{20,22,0,0},
{21,0,18,0},
};
float map_vertices[23][3];
float map_vertices_1[18][3]={
	{-40.0f,0.4f,-40.0f},
	{-20.0f,0.4f,-40.0f},
	{0.0f,0.4f,-40.0f},
	{20.0f,0.4f,-40.0f},

	{-20.0f,0.4f,-20.0f},
	{0.0f,0.4f,-20.0f},
	{20.0f,0.4f,-20.0f},

	{-40.0f,0.4f,0.0f},
	{-20.0f,0.4f,0.0f},
	{0.0f,0.4f,0.0f},
	{20.0f,0.4f,0.0f},

	{-20.0f,0.4f,20.0f},
	{0.0f,0.4f,20.0f},
	{20.0f,0.4f,20.0f},

	{-20.0f,0.4f,40.0f},
	{0.0f,0.4f,40.0f},
	{20.0f,0.4f,40.0f},

	{40.0f,0.4f,0.0f},			//node 18 ,destination
};
float map_vertices_2[23][3]={
	
	{-20.0f,0.4f,-40.0f},
	{0.0f,0.4f,-40.0f},
	{20.0f,0.4f,-40.0f},
	{40.0f,0.4f,-40.0f},

	{-40.0f,0.4f,-20.0f},
	{-20.0f,0.4f,-20.0f},
	{0.0f,0.4f,-20.0f},
	{20.0f,0.4f,-20.0f},
	{40.0f,0.4f,-20.0f},

	{-40.0f,0.4f,0.0f},
	{-20.0f,0.4f,0.0f},
	{0.0f,0.4f,0.0f},
	{20.0f,0.4f,0.0f},
	{40.0f,0.4f,0.0f},

	{-40.0f,0.4f,20.0f},
	{-20.0f,0.4f,20.0f},
	{0.0f,0.4f,20.0f},
	{20.0f,0.4f,20.0f},
	{40.0f,0.4f,20.0f},

	{-20.0f,0.4f,40.0f},
	{0.0f,0.4f,40.0f},
	{20.0f,0.4f,40.0f},

	{-40.0f,0.4f,-40.0f},			//node 23 ,destination
};
struct initLevel
{
    short int MAX_NODES,start_state,destination_state,briefcase_state,minimum_moves;
}obj;

struct guard
{
    short int at_node_number;
    short int holds_node_number;
}active_guard[5];

struct yellow_guard
{
    short int at_node_number;
    short int holds_node_number;
    direction movement;
}active_yellow_guard[5];

void objectives_screen();
void InitDisplayListsLevel1();
void InitDisplayListsLevel2();

void quick_hold_node(int node_number)
{
    for(int i=0;i<obj.MAX_NODES;i++)
    {
        if(map_array[i][node_number-1])
            map_array[i][node_number-1]=-1;
    }
    //increment count of the number of guards holding this node
    node_hold_count[node_number-1]+=1;
}
void quick_release_node(int node_number)
{
    node_hold_count[node_number-1]-=1;
    if(node_hold_count[node_number-1] <= 0)  //only if count is 0 reset map to original
		for(int i=0;i<obj.MAX_NODES;i++)
			map_array[i][node_number-1]=original_map_array[i][node_number-1];   // reset column back to original state
}
void change_environment()
{
    short int i,next_hold;
    direction movement;
    for(i=0;i<yellow_guard_count;i++)
    {
        if(active_yellow_guard[i].at_node_number != -1)             //if Guard is still alive
        {
        //1.move to next node
        active_yellow_guard[i].at_node_number=active_yellow_guard[i].holds_node_number;
        //2.release currently held node
        quick_release_node(active_yellow_guard[i].holds_node_number);
        //3.find next node to hold
        movement=active_yellow_guard[i].movement;
        next_hold=move_array[active_yellow_guard[i].at_node_number-1][movement];
        if(next_hold == 0)  //next_hold ==0,flip direction
        {
            switch(movement)
            {
                case LEFT:  movement=RIGHT;break;
                case RIGHT: movement=LEFT;break;
                case UP:    movement=DOWN;break;
                case DOWN:  movement=UP;break;
            } // movement direction gets updated
        }  //if next_hold !=0 , movement direction remains same
        active_yellow_guard[i].movement=movement;
        next_hold=move_array[active_yellow_guard[i].at_node_number-1][movement];
        //4.actual hold
        quick_hold_node(next_hold);
        active_yellow_guard[i].holds_node_number=next_hold;
        }
    }

}
void check_kill(int player_state)
{
    short int i;
	//1.FOR BLUE GUARDS
    for(i=0;i<guard_count;i++)
    {
        if(active_guard[i].at_node_number == player_state) // if player at same state as guard
        {	//then guard has to be killed
            quick_release_node(active_guard[i].holds_node_number);             //release the node he holds
            //deallocate guard
            active_guard[i].holds_node_number=-1;
            active_guard[i].at_node_number=-1;
        }
    }
	//2.FOR YELLOW GUARDS
     for(i=0;i<yellow_guard_count;i++)
    {
        if(active_yellow_guard[i].at_node_number == player_state)
        {	//then guard has to be killed
            quick_release_node(active_yellow_guard[i].holds_node_number);       //release the node he holds
            //deallocate guard
            active_yellow_guard[i].holds_node_number=-1;
            active_yellow_guard[i].at_node_number=-1;
        }

    }
}
inline void InitGuard(int type,int at,int holds,direction dir)
{
	quick_hold_node(holds);
	if(type == 0)	//BLUE GUARD
	{
		active_guard[guard_count].at_node_number=at;
		active_guard[guard_count++].holds_node_number=holds;
	}
	else		//YELLOW GUARD
	{
		active_yellow_guard[yellow_guard_count].at_node_number=at;
		active_yellow_guard[yellow_guard_count].holds_node_number=holds;
		active_yellow_guard[yellow_guard_count++].movement=dir;
	}
}
void initGameLevel(int level)
{
    short int i,j,temp;
    //RESET GLOBAL VARIABLES
	move_counter=guard_count=yellow_guard_count=0;
    memset(node_hold_count,0,sizeof(node_hold_count));
	briefcase_picked_up=false;
	//RESET CAMERA 
	// actual vector representing the camera's direction
		lx=0.0f;
		lz=-1.0f;
	// XZ position of the camera
		x=0.0f;
		z=100.0f;
	// angle for rotating triangle
		angle=0.0f;

    if(level==1)
    {
        //DEFINE initLevel Structure elements
        current_state=obj.start_state=8;
        obj.destination_state=18;
        obj.briefcase_state=1;
        obj.MAX_NODES=17;
        obj.minimum_moves=14;
		//Generate map_array
        for(i=0;i<obj.MAX_NODES;i++)
            for(j=0;j<4;j++)
                if((temp=move_array_1[i][j]))
                    original_map_array[i][temp-1]=map_array[i][temp-1]=1;

        memcpy(move_array,move_array_1,sizeof(short int)*17*4);
		memcpy(map_vertices,map_vertices_1,sizeof(float)*18*3);

        //PLACE YELLOW GUARDS
		InitGuard(YELLOW,5,2,UP);
		InitGuard(YELLOW,14,17,DOWN);
		//PLACE BLUE GUARDS
		InitGuard(BLUE,3,6,RIGHT);
    }
    else if (level==2)
    {
        //DEFINE initLevel Structure elements
        current_state=obj.start_state=21;
        obj.destination_state=23;
        obj.briefcase_state=14;
        obj.MAX_NODES=22;
        obj.minimum_moves=20;
		//Generate map_array
        for(i=0;i<obj.MAX_NODES;i++)
            for(j=0;j<4;j++)
                if((temp=move_array_2[i][j]))
                    original_map_array[i][temp-1]=map_array[i][temp-1]=1;

        memcpy(move_array,move_array_2,sizeof(short int)*22*4);
		memcpy(map_vertices,map_vertices_2,sizeof(float)*23*3);

        //PLACE YELLOW GUARDS
		InitGuard(YELLOW,18,17,LEFT);
		InitGuard(YELLOW,6,7,RIGHT);
		InitGuard(YELLOW,2,1,LEFT);
		//PLACE BLUE GUARDS
		InitGuard(BLUE,13,8,LEFT);
		InitGuard(BLUE,1,6,LEFT);
		InitGuard(BLUE,10,5,LEFT);
		InitGuard(BLUE,6,5,LEFT);
    }
}
void character_move()
{
	short int temporary_next_node=move_array[current_state-1][dir]; //next possible move

        if(map_array[current_state-1][temporary_next_node-1] == -1)      //is the move in a guards line of sight?
        {
			//Character Killed RESTART LEVEL
			if(Screen == LEVEL1)
				initGameLevel(1);
			else
				initGameLevel(2);
		}
		else if(temporary_next_node > 0)   //direction valid and node not held
        {
            current_state=temporary_next_node;      //move successful
			move_counter++;
            if(current_state == obj.destination_state)                    //destination reached?
            {
				//Check if OBJECTIVES are successful
				if(move_counter == obj.minimum_moves)					
				{
					if(Screen == LEVEL1)
						objectives_flag[1]=true;
					else							//if(Screen == LEVEL2)
						objectives_flag[4]=true;
				}
				if(Screen == LEVEL1)
					objectives_flag[0]=true;
				else								//if(Screen == LEVEL2)
					objectives_flag[3]=true;
				if(briefcase_picked_up)
				{
					if(Screen == LEVEL1)
						objectives_flag[2]=true;
					else 
						objectives_flag[5]=true;
				}
				Screen=OBJECTIVES;			// LEVEL COMPLETE show objectives screen
				glutPostRedisplay();		
            }
			else if(current_state == obj.briefcase_state)
			{
				briefcase_picked_up=true;
			}
            check_kill(current_state);		//check for kill
            change_environment();           //UPDATE YELLOW GUARD POSITION
        }	
}
GLfloat mesh_pole[8][3]={
	{0.0f,0.2f,0.0f},
	{0.5f,0.2f,0.0f},
	{0.5f,0.2f,0.5f},
	{0.0f,0.2f,0.5f},
	{0.0f,4.0f,0.0f},
	{0.5f,4.0f,0.0f},
	{0.5f,4.0f,0.5f},
	{0.0f,4.0f,0.5f},	
};
GLfloat hedge_top[8][3]={
	{0.0,0.0,5.0},	
	{0.0,3.0,5.0},	
	{10.0,3.0,5.0},
	{10.0,0.0,5.0},	
	{0.0,0.0,0.0}, 
	{0.0,3.0,0.0},	
	{10.0,3.0,0.0},	
	{10.0,0.0,0.0},	
};
GLfloat texure_coordinates[8][2] = { 
	 {0.0,0.0}, 
	 {2.0,0.0}, 
	 {2.0,4.0},
	 {0.0,4.0},
	 {0.0,4.0},
	 {2.0,4.0},
	 {2.0,0.0},
	 {0.0,0.0}
};
GLfloat hedge_base[8][3]={
	{0.0f,0.0f,5.0f},	
	{0.0f,0.75f,5.0f},	
	{10.0f,0.75f,5.0f},
	{10.0f,0.0f,5.0f},	
	{0.0f,0.0f,0.0f}, 
	{0.0f,0.75f,0.0f},	
	{10.0f,0.75f,0.0f},	
	{10.0f,0.0f,0.0f}	
};
GLfloat RedChart[6][3]={
	{0.863f, 0.078f, 0.235f},
	{1.000f, 0.000f, 0.000f},
	{0.698f, 0.133f, 0.133f},
	{0.545f, 0.000f, 0.000f},
	{1.000f, 0.271f, 0.000f},
	{0.804f, 0.361f, 0.361f}
};
GLfloat GreenChart[4][3]={
	{0.498f, 1.000f, 0.000f},
	{0.000f, 1.000f, 0.000f},
	{0.196f, 0.804f, 0.196f},
	{0.000f, 0.392f, 0.000f}
};
GLubyte cubeIndices[24]={
0,3,2,1,
2,3,7,6,
0,4,7,3,
1,2,6,5,
4,5,6,7,
0,1,5,4,
};

GLuint loadBMP_custom(const char * imagepath)
{
    // Open the file
    FILE * file = fopen(imagepath,"rb");
    if (!file)
    {
        printf("Image could not be opened\n");
        return 0;
    }
    if ( fread(header, 1, 54, file)!=54 )
    { // If not 54 bytes read : problem
        printf("Not a correct BMP file\n");
        return false;
    }
    if ( header[0]!='B' || header[1]!='M' )
    {
        printf("Not a correct BMP file\n");
        return 0;
    }
    dataPos    = *(int*)&(header[0x0A]);
    imageSize  = *(int*)&(header[0x22]);
    width      = *(int*)&(header[0x12]);
    height     = *(int*)&(header[0x16]);

    // Some BMP files are misformatted, guess missing information
    if (imageSize==0)
        imageSize=width*height*3; // 3 : one byte for each Red, Green and Blue component
    if (dataPos==0)
        dataPos=54; // The BMP header is done that way

    // Create a buffer
    data = new unsigned char [imageSize];

    // Read the actual data from the file into the buffer
    fread(data,1,imageSize,file);

    //Everything is in memory now, the file can be closed
    fclose(file);

}
void changeViewPort(int w, int h)
{
	if (h == 0)
		h = 1;
	float ratio = w * 1.0 / h;
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glViewport(0, 0, w, h);
	gluPerspective(45.0f, ratio, 0.1f, 200.0f);
	glMatrixMode(GL_MODELVIEW);
}
void render_character()
{
	short int i,at_node,holds_node;
	//1.Render Character
		glColor3f(1.000f, 1.000f, 1.000f);
		glPushMatrix();
			glTranslatef(map_vertices[current_state-1][0],0.5f,map_vertices[current_state-1][2]);
			glCallList(CHARACTER);
		glPopMatrix();	
	//2.Render YELLOW Guards
	for(i=0;i<yellow_guard_count;i++)
	{
		if((at_node=active_yellow_guard[i].at_node_number) != -1)
		{
			holds_node=active_yellow_guard[i].holds_node_number;
			glColor3f(1.000f, 1.000f, 0.000f);
			glPushMatrix();
				glTranslatef(map_vertices[at_node-1][0],0.5f,map_vertices[at_node-1][2]);
				glCallList(CHARACTER);
			glPopMatrix();
			glLineWidth(3);
			glColor3f(1.000f, 0.000f, 0.000f);
			glBegin(GL_LINES);
				glVertex3f(map_vertices[at_node-1][0],3.0f,map_vertices[at_node-1][2]);
				glVertex3f(map_vertices[holds_node-1][0],3.0f,map_vertices[holds_node-1][2]);
			glEnd();
		}
	}
	//3.Render BLUE Guards
	for(i=0;i<guard_count;i++)
	{
		if((at_node=active_guard[i].at_node_number) != -1)
		{
			holds_node=active_guard[i].holds_node_number;
			glColor3f(0.000f, 0.000f, 1.000f);
			glPushMatrix();
				glTranslatef(map_vertices[at_node-1][0],0.5f,map_vertices[at_node-1][2]);
				glCallList(CHARACTER);
			glPopMatrix();
			glLineWidth(3);
			glColor3f(1.000f, 0.000f, 0.000f);
			glBegin(GL_LINES);
				glVertex3f(map_vertices[at_node-1][0],3.0f,map_vertices[at_node-1][2]);
				glVertex3f(map_vertices[holds_node-1][0],3.0f,map_vertices[holds_node-1][2]);
			glEnd();
		}
	}
	//4.Render Briefcase
	if(!briefcase_picked_up)
	{
			glPointSize(12);
			glColor3f(1.000f, 0.647f, 0.000f);
			glBegin(GL_POINTS);
			glVertex3f(map_vertices[obj.briefcase_state-1][0],5.0f,map_vertices[obj.briefcase_state-1][2]);
			glEnd();
	}
	//5.Render TARGET
		glColor3f(1.0f,0.0f,0.0f);
		glPushMatrix();
			glTranslatef(map_vertices[obj.destination_state-1][0],0.5f,map_vertices[obj.destination_state-1][2]);
			glCallList(CHARACTER);
		glPopMatrix();
}
void mymouse(int button,int state,int x,int y)
{
	if( Screen == START && button==GLUT_LEFT_BUTTON && state ==GLUT_DOWN)
	{
		short int width,height;
		//Get window attributes
		width=glutGet(GLUT_WINDOW_WIDTH);
		height=glutGet(GLUT_WINDOW_HEIGHT);
		//Invert y co-ordinate to get actual screen value
		y=height-y;

		if((x>(0.25*width)) && (x<(0.4*width)) && (y>(0.4*height)) && (y<(0.6*height)))			// level 1 selection 
		{
			PreviousScreen=Screen=LEVEL1;
			initGameLevel(1);
			InitDisplayListsLevel1();
			glutPostRedisplay();
		}
		else if((x>(0.6*width)) && (x<(0.75*width)) && (y>(0.4*height)) && (y<(0.6*height)))	//level 2 selection
		{
			PreviousScreen=Screen=LEVEL2;
			initGameLevel(2);
			InitDisplayListsLevel2();
			glutPostRedisplay();
		}
		else if((x>(0.92*width)) && (x<(0.98*width)) && (y>(0.7*height)) && (y<(0.75*height)))	//QUIT selection
		{
			exit(0);	
		}
	}

	else if (Screen == OBJECTIVES && button==GLUT_LEFT_BUTTON && state ==GLUT_DOWN)
	{
		if(current_state == obj.destination_state)
		{
			Screen=PreviousScreen=START;
			glutPostRedisplay();
		}
		else
		{
			Screen=PreviousScreen;
			glutPostRedisplay();
		}
	}
	else if (Screen == INSTRUCTIONS && button==GLUT_LEFT_BUTTON && state ==GLUT_DOWN)
	{
		Screen=PreviousScreen;
		glutPostRedisplay();
	}
}
void mykeyboard(unsigned char key,int x,int y)
{
	if(Screen == LEVEL1 || Screen == LEVEL2)
		switch(key)
		{
			case 'A':
			case 'a':	dir=LEFT;character_move();break;
			case 'D':
			case 'd':	dir=RIGHT;character_move();break;
			case 'W':
			case 'w':	dir=UP;character_move();break;
			case 'S':
			case 's':	dir=DOWN;character_move();break;
			case 'O':
			case 'o':	PreviousScreen=Screen;Screen=OBJECTIVES;break;
		}
	if(key =='i' && (Screen != OBJECTIVES) && (Screen != INSTRUCTIONS))
	{
		PreviousScreen=Screen;
		Screen=INSTRUCTIONS;
	}
	switch(key)
	{
		case 8:		PreviousScreen=Screen=START;break;
		//case 27:	exit(0);
	}
}
inline void write_text(GLfloat x, GLfloat y, char *text)
{
	char *p;
	glRasterPos2f(x,y);
	for (p = text; *p; p++)
		glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24,*p);
}
void abstract_tiles()
{
	short int x[22]={0},y[13]={glutGet(GLUT_WINDOW_HEIGHT)},i,j;
	//nx=Number of quads to be drawn in X-axis
	//ny=Number of quads to be drawn in Y-axis
	float nx=(float)glutGet(GLUT_WINDOW_WIDTH)/100.0f,ny=(float)glutGet(GLUT_WINDOW_HEIGHT)/100.0f;
	nx=ceil(nx);
	ny=ceil(ny);
	//1.Compute Points
	for(i=1;i<=nx;i++)
		x[i]=x[i-1]+100;
	for(i=1;i<=ny;i++)
		y[i]=y[i-1]-20;
	//2.Draw Quads
	for(i=0;i<nx;i++)
		for(j=0;j<ny;j++)
		{
			glColor3fv(RedChart[(i+j)%6]);	//specify a random shade of RED for the QUAD
			glBegin(GL_QUADS);
				glVertex2f(x[i],y[j]);
				glVertex2f(x[i+1],y[j]);
				glVertex2f(x[i+1],y[j+1]);
				glVertex2f(x[i],y[j+1]);
			glEnd();
		}
}
void objectives_screen()
{
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	
	glutSetWindowTitle("Objectives");
	gluOrtho2D(0,glutGet(GLUT_WINDOW_WIDTH),0,glutGet(GLUT_WINDOW_HEIGHT));
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glDisable(GL_DEPTH_TEST);
	glClearColor(1.0f,1.0f,1.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT);

	//Generate abstract_tiles
	abstract_tiles();
	//Generate KEY_LEGEND
	glCallList(KEY_LEGEND);

	short int width,height,index;
	width=glutGet(GLUT_WINDOW_WIDTH);
	height=glutGet(GLUT_WINDOW_HEIGHT);

	glColor3f(1.0f,0.0f,0.0f);
	glRectf(0.1*width,0.4*height,0.3*width,0.6*height);
	glRectf(0.4*width,0.4*height,0.6*width,0.6*height);
	glRectf(0.7*width,0.4*height,0.9*width,0.6*height);
	glColor3f(0.0f,0.0f,0.0f);
	glRectf(0.1*width,0.6*height,0.3*width,0.64*height);
	glRectf(0.4*width,0.6*height,0.6*width,0.64*height);
	glRectf(0.7*width,0.6*height,0.9*width,0.64*height);
	
	glColor3f(1.0f,1.0f,1.0f);
	write_text(0.18*width,0.61*height,"EASY");
	write_text(0.47*width,0.61*height,"MEDIUM");
	write_text(0.78*width,0.61*height,"HARD");

	write_text(0.14*width,0.54*height,"KILL THE");
	write_text(0.14*width,0.5*height,"TARGET");
	write_text(0.42*width,0.54*height,"COMPLETE IN");
	if(PreviousScreen == LEVEL1)
		write_text(0.42*width,0.5*height,"14 TURNS");
	else
		write_text(0.42*width,0.5*height,"20 TURNS");
	write_text(0.74*width,0.54*height,"COLLECT ");
	write_text(0.74*width,0.5*height,"BRIEFCASE");

	glRectf(0.19*width,0.44*height,0.21*width,0.46*height);
	glRectf(0.49*width,0.44*height,0.51*width,0.46*height);
	glRectf(0.79*width,0.44*height,0.81*width,0.46*height);
	
	
	if(current_state == obj.destination_state)
	 {
		glColor3f(0.0f,0.0f,0.0f);
		write_text(0.06*width,0.7*height,"LEFT CLICK - RETURN TO THE MAIN MENU");
	 }
	else
	{
		glColor3f(0.0f,0.0f,0.0f);
		write_text(0.06*width,0.7*height,"LEFT CLICK - RETURN TO THE GAME");
	}
	
	index=(PreviousScreen == LEVEL1)?0:3;
	
	glLineWidth(3);
	//Generate OBJECTIVE COMPLETE CROSS MARKS
	 if(objectives_flag[index+0])
	{
		glColor3f(1.0f,0.0f,0.0f);
		glBegin(GL_LINES);
		glVertex2f(0.19*width,0.44*height);
		glVertex2f(0.21*width,0.46*height);
		glVertex2f(0.19*width,0.46*height);
		glVertex2f(0.21*width,0.44*height);
		glEnd();
		
	}
	if(objectives_flag[index+1])
	{
		glColor3f(1.0f,0.0f,0.0f);
		glBegin(GL_LINES);
		glVertex2f(0.49*width,0.44*height);
		glVertex2f(0.51*width,0.46*height);
		glVertex2f(0.49*width,0.46*height);
		glVertex2f(0.51*width,0.44*height);
		glEnd();
	}
	if(objectives_flag[index+2])
	{
		glColor3f(1.0f,0.0f,0.0f);
		glBegin(GL_LINES);
		glVertex2f(0.79*width,0.44*height);
		glVertex2f(0.81*width,0.46*height);
		glVertex2f(0.79*width,0.46*height);
		glVertex2f(0.81*width,0.44*height);
		glEnd();
	}

	glutSwapBuffers();
	glFlush();

	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_DEPTH_TEST);
}
void instruction_screen()
{
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	
	glutSetWindowTitle	("INSTRUCTIONS");
	gluOrtho2D(0,glutGet(GLUT_WINDOW_WIDTH),0,glutGet(GLUT_WINDOW_HEIGHT));
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glDisable(GL_DEPTH_TEST);
	glClearColor(1.0f,1.0f,1.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT );

	short int width,height;
	width=glutGet(GLUT_WINDOW_WIDTH);
	height=glutGet(GLUT_WINDOW_HEIGHT);
	glColor3f(1.0f,0.0f,0.0f);	
	write_text(0.02*width,.975*height,"Introduction to the game:");
	write_text(0.04*width,.58*height,"Controls");
	write_text(0.04*width,.52*height,"Character Movement:");
	write_text(0.04*width,.30*height,"Camera:");
	write_text(0.04*width,.20*height,"Miscellaneous:");
	write_text(0.6*width,.62*height,"KEY:");
	write_text(0.5*width,0.16*height,"LEFTCLICK - RETURN TO PREVIOUS SCREEN");
	write_text(10.0f,0.62*height,"TIP: Familiarize yourself with YELLOW GUARD movement patterns");


	glColor3f(0.0f,0.0f,0.0f);
	write_text(0.0f,.94*height,"-Hitman is a turn-based puzzle game ");
	write_text(0.0f,.90*height,"-In every level,You will strategically navigate fixed spaces on a grid to avoid enemies");
	write_text(0.0f,.86*height,"-The core objective in each level is to kill assigned targets.Additionally each level has a set of objectives of varying difficulty");
	write_text(0.0f,.82*height,"-The game comprises of Different enemy types, each unique in their own right. Each enemy type is dressed in a unique color, allowing the player to recognize their movement patterns");
	write_text(0.0f,.78*height,"-With every player move,the environment changes.BLUE GUARDS  remain static on a single node, while YELLOW GUARDS will patrol the map along a specific route. ");
	write_text(0.0f,.74*height,"-With every move you make, an enemy’s location on the map may change. You really have to think about each move");
	write_text(0.0f,.70*height,"-If the character enters a guard's line of sight,the character will die and the level will be restarted ");
	write_text(0.0f,.66*height,"-To kill a guard ,the character has to be in the same node as that of the guard");
	
	write_text(0.04*width,.48*height,"'W'- Move FRONT");
	write_text(0.04*width,.44*height,"'A'- Move LEFT");
	write_text(0.04*width,.40*height,"'S'- Move BACK");
	write_text(0.04*width,.36*height,"'D'- Move RIGHT");
	write_text(0.04*width,.26*height,"Use Arrow Keys to move the Camera");
	write_text(0.04*width,.16*height,"Press 'o' or 'O' To VIEW current level OBJECTIVES");
	write_text(0.04*width,.12*height,"Press 'i' or 'I' To VIEW INSTRUCTIONS");
	write_text(0.04*width,.08*height,"Press Backspace to RETURN to the MAIN MENU");
	//write_text(0.04*width,.04*height,"Press ESC To EXIT the Game  ");
	

	//TEXT FOR KEY LEGEND
	write_text(0.66*width,.57*height,"CHARACTER");
	write_text(0.66*width,.51*height,"BLUE GUARD");
	write_text(0.66*width,.45*height,"YELLOW GUARD");
	write_text(0.66*width,.39*height,"GUARD'S LINE OF SIGHT");
	write_text(0.66*width,.33*height,"BRIEFCASE(OBJECTIVE)");
	write_text(0.66*width,.27*height,"TARGET(OBJECTIVE)");

	//GENERATE KEY LEGEND
	glRectf(0.6*width,0.56*height,0.64*width,0.6*height);
	glRectf(0.6*width,0.50*height,0.64*width,0.54*height);
	glRectf(0.6*width,0.44*height,0.64*width,0.48*height);
	glRectf(0.6*width,0.38*height,0.64*width,0.42*height);
	glRectf(0.6*width,0.32*height,0.64*width,0.36*height);
	glRectf(0.6*width,0.26*height,0.64*width,0.30*height);

	//character
	glColor3f(1.0f,1.0f,1.0f);
	glRectf(0.61*width,0.57*height,0.63*width,0.59*height);
	//blue guard
	glColor3f(0.000f, 0.000f, 1.000f);
	glRectf(0.61*width,0.51*height,0.63*width,0.53*height);
	//yellow guard
	glColor3f(1.000f, 1.000f, 0.000f);
	glRectf(0.61*width,0.45*height,0.63*width,0.47*height);
	//line of sight
	glColor3f(1.000f, 0.000f, 0.000f);
	glLineWidth(3);
	glBegin(GL_LINES);
	glVertex2f(0.6*width,0.4*height);
	glVertex2f(0.64*width,0.4*height);
	glEnd();
	//TARGET (red color)
	glRectf(0.61*width,0.27*height,0.63*width,0.29*height);
	//Briefcase 
	glColor3f(1.000f, 0.647f, 0.000f);
	glRectf(0.61*width,0.33*height,0.63*width,0.35*height);
	
	
	glutSwapBuffers();
	glFlush();
	
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_DEPTH_TEST);
	
}
void get_score()
{
	objectives_completed_count=0;
	int i;
	for(i=0;i<6;i++)
		if(objectives_flag[i])
			objectives_completed_count+=1;
}
void start_screen()
{
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	
	glutSetWindowTitle	("Main Menu");
	gluOrtho2D(0,glutGet(GLUT_WINDOW_WIDTH),0,glutGet(GLUT_WINDOW_HEIGHT));
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glDisable(GL_DEPTH_TEST);
	glClearColor(1.0f,1.0f,1.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT );
	short int width,height;
	width=glutGet(GLUT_WINDOW_WIDTH);
	height=glutGet(GLUT_WINDOW_HEIGHT);

	abstract_tiles();
	
	glColor3f(1.0f,0.0f,0.0f);
	glRectf(0.25*width,0.4*height,0.4*width,0.6*height);
	glRectf(0.60*width,0.4*height,0.75*width,0.6*height);
	glRectf(0.92*width,0.70*height,0.99*width,0.75*height);

	write_text(768,324,"OBJECTIVES COMPLETED :");
	get_score();
	char itoaBuffer [33];
	write_text(1090,324,itoa(objectives_completed_count,itoaBuffer,10));
	if(objectives_completed_count == 6)
	{	
		write_text(624,216,"CONGRATULATIONS! YOU HAVE COMPLETED THE GAME!");
		write_text(624,180,"IF YOU WISH TO,YOU CAN RE-PLAY THE LEVELS");
	}
	glColor3f(0.0f,0.0f,0.0f);
	write_text(0.30*width,0.55*height,"Level 1");
	write_text(0.65*width,0.55*height,"Level 2");
	write_text(0.93*width,0.72*height,"QUIT");
	write_text(0.05*width,0.64*height,"PRESS 'i' or 'I' To VIEW INSTRUCTIONS");

	if(objectives_flag[0] && objectives_flag[1] && objectives_flag[2])		// all LEVEL1 objectives complete
	{
		glLineWidth(3);
		glBegin(GL_LINES);
			glVertex2f(0.25*width,0.4*height);
			glVertex2f(0.4*width,0.6*height);
			glVertex2f(0.25*width,0.6*height);
			glVertex2f(0.4*width,0.4*height);
		glEnd();
	}
	if(objectives_flag[3] && objectives_flag[4] && objectives_flag[5])		// all LEVEL2 objectives complete
	{
		glLineWidth(3);
		glBegin(GL_LINES);
			glVertex2f(0.6*width,0.4*height);
			glVertex2f(0.75*width,0.6*height);
			glVertex2f(0.6*width,0.6*height);
			glVertex2f(0.75*width,0.4*height);
		glEnd();
	}
	// DRAW PLAY SYMBOL
	glBegin(GL_TRIANGLES);
		glVertex2f(0.3*width,0.45*height); 
		glVertex2f(0.3*width,0.50*height); 
		glVertex2f(0.35*width,0.475*height);

		glVertex2f(0.65*width,0.45*height);
		glVertex2f(0.65*width,0.50*height);
		glVertex2f(0.7*width,0.475*height);
	glEnd();

	glColor3f(1.0f,0.0f,0.0f);
	glPushMatrix();
	glTranslatef(.33*width,0.72*height,0);
	glScalef(.28,.28,.28);
	glLineWidth(3);
	char text[]="WELCOME, PLEASE SELECT A LEVEL";
	for (char *p = text; *p; p++)
		glutStrokeCharacter(GLUT_STROKE_ROMAN,*p);
	glPopMatrix();

	

	glutSwapBuffers();
	glFlush();
	
	
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_DEPTH_TEST);
}
void init()
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-70.0f,70.0f,0.0f,250.0f,-70.0f,70.0f);
	glMatrixMode(GL_MODELVIEW);
}
void draw_skybox()
{
	if(Screen == 1)
		GLuint Texture = loadBMP_custom("C:/Users/Sushant/Desktop/sky.bmp");
	else
		GLuint Texture = loadBMP_custom("C:/Users/Sushant/Desktop/nightsky.bmp");
	glEnable(GL_TEXTURE_2D);
	GLuint textureID;
	glGenTextures(1, &textureID);
	glBindTexture(GL_TEXTURE_2D, textureID);
    // Set texture filtering parameters
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	// create texture and 
	glTexImage2D(GL_TEXTURE_2D, 0,GL_RGB, width, height, 0, GL_BGR, GL_UNSIGNED_BYTE, data);
	// generate mipmaps
	glGenerateMipmap(GL_TEXTURE_2D);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
	glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_LOD_BIAS,-0.5f);
	
	glColor3f(1.0f,1.0f,1.0f);
		glBegin(GL_QUADS);
		//back
		glTexCoord2f(0.0f, 0.0f);	glVertex3f(-55.0f, 0.0f, -50.0f);
		glTexCoord2f(0.0f, 1.0f);	glVertex3f(-55.0f, 90.0f, -50.0f);
		glTexCoord2f(1.0f, 1.0f);	glVertex3f( 55.0f, 90.0f, -50.0f);
		glTexCoord2f(1.0f, 0.0f);	glVertex3f( 55.0f, 0.0f, -50.0f);
		//left
		glTexCoord2f(0.0f, 0.0f);	glVertex3f(-55.0f, 0.0f, -50.0f);
		glTexCoord2f(1.0f, 0.0f);	glVertex3f(-55.0f, 0.0f, 50.0f);
		glTexCoord2f(1.0f, 1.0f);	glVertex3f(-55.0f, 90.0f, 50.0f);
		glTexCoord2f(0.0f, 1.0f);	glVertex3f(-55.0f, 90.0f, -50.0f);
		//right
		glTexCoord2f(0.0f, 0.0f);	glVertex3f(55.0f, 0.0f, -50.0f);
		glTexCoord2f(1.0f, 0.0f);	glVertex3f(55.0f, 0.0f, 50.0f);
		glTexCoord2f(1.0f, 1.0f);	glVertex3f(55.0f, 90.0f, 50.0f);
		glTexCoord2f(0.0f, 1.0f);	glVertex3f(55.0f, 90.0f, -50.0f);

	glEnd();
	glBindTexture(GL_TEXTURE_2D, 0); // Unbind texture
	delete []data;
	glDeleteTextures(1, &textureID);
	glDisable(GL_TEXTURE_2D);
	
}
void draw_map()
{
	GLuint Texture = loadBMP_custom("C:/Users/Sushant/Desktop/grass.bmp");
	glEnable(GL_TEXTURE_2D);
	GLuint textureID;
	glGenTextures(1, &textureID);
	glBindTexture(GL_TEXTURE_2D, textureID);
	// Set the texture wrapping parameters
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);	
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // Set texture filtering parameters
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	// create texture and 
	glTexImage2D(GL_TEXTURE_2D, 0,GL_RGB, width, height, 0, GL_BGR, GL_UNSIGNED_BYTE, data);
	// generate mipmaps
	glGenerateMipmap(GL_TEXTURE_2D);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
	glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_LOD_BIAS,-0.5f);
	
	glCallList(MAP);

	glBindTexture(GL_TEXTURE_2D, 0); // Unbind texture
	delete []data;
	glDeleteTextures(1, &textureID);
	glDisable(GL_TEXTURE_2D);
}
void draw_trees()
{
	//1
	glPushMatrix();
		glTranslatef(10.0f,0.5f,-20.0f);
		glCallList(TREE);
	glPopMatrix();
	//2
	for(short int i=0;i<12;i++)
	{
	glPushMatrix();
		glTranslatef(-47.0f,0.5f,-40.0f+(i*8.0f));
		glCallList(TREE);
	glPopMatrix();
	}
}
void recording_symbol()
{
	glColor3f(1.0f,0.0f,0.0f);
	glRectf(50,50,70,200);
	glRectf(50,880,70,1030);
	glRectf(1850,50,1870,200);
	glRectf(1850,880,1870,1030);
	glRectf(50,1010,200,1030);
	glRectf(50,50,200,70);
	glRectf(1720,1010,1870,1030);
	glRectf(1720,50,1870,70);
	//recording text
	glPushMatrix();
	glColor3f(1,0,0);
	glTranslatef(1500,920,0);
	glScalef(.35,.35,.35);
	glLineWidth(3);
	char *p,text[]="RECORDING";
	for (p = text; *p; p++)
		glutStrokeCharacter(GLUT_STROKE_ROMAN,*p);
	glPopMatrix();

}
void draw_pixel(GLint cx, GLint cy)
{
	glPointSize(3);
	glBegin(GL_POINTS);
		glVertex2i(cx,cy);
	glEnd();
}
void plotpixels(GLint h,GLint k, GLint x,GLint y)
{
	draw_pixel(x+h,y+k);
	draw_pixel(-x+h,y+k);
	draw_pixel(x+h,-y+k);
	draw_pixel(-x+h,-y+k);
	draw_pixel(y+h,x+k);
	draw_pixel(-y+h,x+k);
	draw_pixel(y+h,-x+k);
	draw_pixel(-y+h,-x+k);
}
void draw_circle(GLint h, GLint k, GLint r)
{
	GLint d=1-r, x=0, y=r;
	while(y>x)
	{
		plotpixels(h,k,x,y);
		if(d<0) d+=2*x+3;
		else
		{
			d+=2*(x-y)+5;
			--y;
		}
		++x;
	}
	plotpixels(h,k,x,y);
}
void cutscene_objects()
{
	glClearColor(0.000, 0.749, 1.000,0.0f);
	glClear(GL_COLOR_BUFFER_BIT );

	glCallList(CUTSCENE_BACKGROUND);

	//car
	glColor3f(0.0,1.0,1.0);
	glBegin(GL_POLYGON);
	glVertex2f(-470+i,300);
	glVertex2f(-470+i,375);
	glVertex2f(-400+i,375);
	glVertex2f(-372+i,460);
	glVertex2f(-210+i,460);
	glVertex2f(-180+i,375);
	glVertex2f(-130+i,362);
	glVertex2f(-80+i,300);
	glEnd();
	//windows
	glColor3f(0.1,0.1,0.1);
	glBegin(GL_POLYGON);
	glVertex2f(-410+i,375);
	glVertex2f(-364+i,450);
	glVertex2f(-300+i,450);
	glVertex2f(-300+i,375);
	glEnd();

	glColor3f(0.1,0.1,0.1);
	glBegin(GL_POLYGON);
	glVertex2f(-290+i,375);
	glVertex2f(-290+i,450);
	glVertex2f(-217+i,450);
	glVertex2f(-192+i,375);
	glEnd();
	//draw TYRES
	glColor3f(0.0,0.0,0.0);
	for(int l=0;l<30;l++)
	{
		draw_circle(-400+i,300,l);
		draw_circle(-200+i,300,l);
	}
	
	recording_symbol();
	glPushMatrix();
	glColor3f(1,0,0);
	glTranslatef(650,480,0);
	glScalef(.35,.35,.35);
	glLineWidth(3);
	char *p,text[]="THE TARGET IS ARRIVING";
	for (p = text; *p; p++)
		glutStrokeCharacter(GLUT_STROKE_ROMAN,*p);
	glPopMatrix();

	glutSwapBuffers();
	glFlush();
}
void cutscene_objects_target_moving()	//Front view of character
{
	glClearColor(1.0,1.0, 1.000,0.0f);
	glClear(GL_COLOR_BUFFER_BIT );

	//road
	glColor3f(0.2,0.2,0.2);
	glRectf(0.0f,0.0f,600.0f,1080.0f);
	//road markers
	glColor3f(1.0,1.0,1.0);
	for(int j=0;j<=1100;j+=200)
		glRectf(220.0f,100.0f+j,240.0f,200.0f+j);
	//SIDE WALK
	glRectf(600.0f,0.0f,750.0f,1080.0f);
	//SIDE WALK LINES
	glLineWidth(5);
	glColor3f(0,0,0);
	for(int j=0;j<=1000;j+=100)
	{
		glBegin(GL_LINES);
			glVertex2f(600,100+j);
			glVertex2f(750,100+j);
		glEnd();	
	}
	//Grass
	glColor3f(0.196, 0.804, 0.196);
	glRectf(750.0f,0.0f,1920.0f,1080.0f);

	glPushMatrix();
	glScalef(1.0,0.8,0.0);

	//RENDER TARGET
	//torso
	glColor3f(1.0,0.0,0.0);
	glRectf(600+i,480,700+i,650);
	//face 
	glColor3f(1.000f, 0.714f, 0.757f);//SKIN TONE
	glRectf(620+i,650,680+i,700);
	//hands
	glRectf(580+i,500,600+i,630);
	glRectf(700+i,500,720+i,630);
	//legs
	glRectf(605+i,380,625+i,480);
	glRectf(675+i,380,695+i,480);
	//Belt
	glColor3f(0,0,0);
	glRectf(600+i,530,700+i,545);
	//hair
	glRectf(620+i,700,680+i,710);
	//shoes
	glRectf(580+i,360,625+i,380);
	glRectf(675+i,360,720+i,380);
	//eyes
	glRectf(630+i,680,635+i,685);
	glRectf(665+i,680,670+i,685);
	//mouth
	glBegin(GL_LINES);
	glVertex2f(630+i,665);
	glVertex2f(670+i,665);
	glEnd();
	//BELT BUCKLE
	glColor3f(1.000f, 0.843f, 0.000f);
	glRectf(640+i,525,660+i,550);

	glPopMatrix();

	recording_symbol();

	glPushMatrix();
	glColor3f(1,0,0);
	glTranslatef(500+i,750,0);
	glScalef(.35,.35,.35);
	glLineWidth(3);
	char *p,text[]="TARGET IDENTIFIED";
	for (p = text; *p; p++)
		glutStrokeCharacter(GLUT_STROKE_ROMAN,*p);
	glPopMatrix();
	
	glPushMatrix();
	glColor3f(1,0,0);
	glTranslatef(430+i,650,0);
	glScalef(.35,.35,.35);
	glLineWidth(3);
	char text1[]="MISSION - KILL TARGET";
	for (p = text1; *p; p++)
		glutStrokeCharacter(GLUT_STROKE_ROMAN,*p);
	glPopMatrix();

	glutSwapBuffers();
	glFlush();

}
void cutscene()
{
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	
	glutSetWindowTitle	("Cutscene");
	gluOrtho2D(0,glutGet(GLUT_WINDOW_WIDTH),0,glutGet(GLUT_WINDOW_HEIGHT));
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glDisable(GL_DEPTH_TEST);
	glClearColor(1.0f,1.0f,1.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT );


	//TARGET IS ARRIVING
	for(i=0;i<=1400;i+=0.2)
		cutscene_objects();
	//TARGET GETS OUT OF THE CAR AND MOVES
	for(i=0;i<=1320;i+=0.1)
		cutscene_objects_target_moving();
	glutSwapBuffers();
	glFlush();
	
	
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_DEPTH_TEST);
}
void render()
{
	if(Screen == CUTSCENE )
	{
		cutscene();
		Screen=START;
	}
	//2.RENDER START SCREEN
	else if(Screen == START)
		start_screen();
	//3.RENDER LEVEL1
	else if(Screen == LEVEL1)
	{
		glClearColor(0.0f,0.0f,0.0f,0.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glLoadIdentity();
		glutSetWindowTitle("LEVEL 1");

		// Set the camera
		gluLookAt(	x, 20.0f, z,
		x+lx, 20.0f, z+lz,
		0.0f, 1.0f, 0.0f);	

		//RENDER LEVEL 1
		glCallList(NODES_1);
		glCallList(ROAD);
		glCallList(FENCE);
		glCallList(HEDGE_MULTIPLE_1);
		glCallList(HOUSE);

		draw_map();
		draw_trees();
		draw_skybox();
		render_character();
		//END LEVEL 1

		glutSwapBuffers();
		glFlush();
	}
	//4.RENDER LEVEL2
	else if(Screen == LEVEL2)
	{
		glClearColor(0.0f,0.0f,0.0f,0.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glLoadIdentity();
		glutSetWindowTitle	("LEVEL 2");

		// Set the camera
		gluLookAt(	x, 20.0f, z,
		x+lx, 20.0f, z+lz,
		0.0f, 1.0f, 0.0f);	
		
		//RENDER LEVEL 2
		glCallList(NODES_2);
		glCallList(ROAD);
		glPushMatrix();
			glRotatef(270.0,0.0f,1.0f,0.0);
			glCallList(HOUSE);
		glPopMatrix();
		//glCallList(HEDGE_MULTIPLE_2);
		
		draw_map();
		draw_trees();
		draw_skybox();
		render_character();
		//END LEVEL 2

		glutSwapBuffers();
		glFlush();
	}
	//5.RENDER OBJECTIVES SCREEN
	else if(Screen == OBJECTIVES)
		objectives_screen();
	//6.RENDER INSTRUCTIONS SCREEN
	else //if(Screen == INSTRUCTIONS)
		instruction_screen();
}
void InitDisplayLists()
{
	glNewList(CUTSCENE_BACKGROUND,GL_COMPILE);
		//road
		glColor3f(0.2,0.2,0.2);
		glRectf(0.0f,0.0f,1920.0f,400.0f);
		//road markers
		glColor3f(1.0,1.0,1.0);
		for(int j=0;j<=1800;j+=200)
			glRectf(0.0f+j,200.0f,100.0f+j,220.0f);
		//SIDE WALK
		glRectf(0.0f,400.0f,1920.0f,420.0f);
		//Grass
		glColor3f(0.196, 0.804, 0.196);
		glRectf(0.0f,420.0f,1920.0f,600.0f);
		//buildings
		glColor3f(0.961, 0.961, 0.863);
		glRectf(100,600,300,1050);

		glColor3f(1.000, 0.647, 0.000);
		glRectf(850,600,1150,1000);
		//building windows
		glColor3f(0,0,0);
		glLineWidth(5);
		for(int j =0;j<=300;j+=100)
		{
			glRectf(190,640+j,210,670+j);
			glBegin(GL_LINES);
				glVertex2f(100,700+j);
				glVertex2f(300,700+j);
			glEnd();
		}
		glColor3f(1.000, 0.714, 0.757);
		glRectf(350,600,800,750);
		glColor3f(1.000, 0.980, 0.980);
		glRectf(600,650,700,710);
		for(int j =0;j<=300;j+=100)
		{
			glRectf(880,640+j,910,670+j);
			glRectf(1090,640+j,1120,670+j);
		}
		glLineWidth(5);
		glBegin(GL_LINES);
			glVertex2f(1000,1000);
			glVertex2f(1000,600);
		glEnd();
		glColor3f(0.627, 0.322, 0.176);
		glRectf(400,600,450,670);
	glEndList();
	//list 1 MAP
	glNewList(MAP,GL_COMPILE);
	//	draw ground
		glColor3f(1.0f,1.0f,1.0f);
		glBegin(GL_QUADS);
			glTexCoord2f(0.0f, 0.0f);	glVertex3f(-60.0f, 0.0f, -50.0f);
			glTexCoord2f(0.0f, 5.0f);	glVertex3f(-60.0f, 0.0f, 60.0f);
			glTexCoord2f(5.0f, 5.0f);	glVertex3f( 60.0f, 0.0f, 60.0f);
			glTexCoord2f(5.0f, 0.0f);	glVertex3f( 60.0f, 0.0f, -50.0f);
		glEnd();
	glEndList();
	
	//list 3 HEDGE_SINGLE
	glNewList(HEDGE_SINGLE,GL_COMPILE);
		//Draw base
		glVertexPointer(3,GL_FLOAT,0,hedge_base);
		glColor3f(0.961f, 0.871f, 0.702f);
		glDrawElements(GL_QUADS,24,GL_UNSIGNED_BYTE,cubeIndices);
		//Draw top
		GLuint Texture_hedge = loadBMP_custom("C:/Users/Sushant/Desktop/grass2.bmp");
		glEnable(GL_TEXTURE_2D);
		glEnableClientState(GL_TEXTURE_COORD_ARRAY);
		GLuint textureID_hedge;
		glGenTextures(1, &textureID_hedge);
		glBindTexture(GL_TEXTURE_2D, textureID_hedge);
		// Set the texture wrapping parameters
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);	
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
		// Set texture filtering parameters
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		// create texture 
		glTexImage2D(GL_TEXTURE_2D, 0,GL_RGB, width, height, 0, GL_BGR, GL_UNSIGNED_BYTE, data);
		
		glColor3f(0.196f, 0.804f, 0.196f);
		glVertexPointer(3,GL_FLOAT,0,hedge_top);
		glTexCoordPointer( 2, GL_FLOAT, 0,texure_coordinates);
		glTranslatef(0.0f,0.75f,0.0f);
		glDrawElements(GL_QUADS,24,GL_UNSIGNED_BYTE,cubeIndices);

		glDisableClientState(GL_TEXTURE_COORD_ARRAY);
		glBindTexture(GL_TEXTURE_2D, 0);	// Unbind texture 
		delete []data;
		glDeleteTextures(1, &textureID_hedge);
		glDisable(GL_TEXTURE_2D);

	glEndList();
	//list4 TREE
	glNewList(TREE,GL_COMPILE);
		GLUquadricObj *quadratic;
		GLUquadricObj *quadratic1;
		quadratic1 = gluNewQuadric();
		quadratic = gluNewQuadric();
		glColor3f(0.627f, 0.322f, 0.176f);
		glPushMatrix();
			glRotatef(-90.0f, 1.0f, 0.0f, 0.0f);
			gluCylinder(quadratic,1,1,10.0f,32,32);
		glPopMatrix();
		glTranslatef(0,2,0);
		glPushMatrix();
			for(int i=0,j=0;i<4;i++,j+=0.5)
			{
				glColor3fv(GreenChart[i]);
				glTranslatef(0,1.8,0);
				glPushMatrix();
					glRotatef(-90.0f, 1.0f, 0.0f, 0.0f);
					gluCylinder(quadratic1,3.0-j,0,4.0f,32,32);
				glPopMatrix();
			}
		glPopMatrix();
	glEndList();
	// LIST 10 ROAD
	glNewList(ROAD,GL_COMPILE);
		GLuint Texture_road = loadBMP_custom("C:/Users/Sushant/Desktop/road.bmp");
		glEnable(GL_TEXTURE_2D);
		GLuint textureID_road;
		glGenTextures(1, &textureID_road);
		glBindTexture(GL_TEXTURE_2D, textureID_road);
		// Set the texture wrapping parameters
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);	
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
		// Set texture filtering parameters
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTexImage2D(GL_TEXTURE_2D, 0,GL_RGB, width, height, 0, GL_BGR, GL_UNSIGNED_BYTE, data);
		
		glColor3f(1.0f,1.0f,1.0f);
		glBegin(GL_QUADS);
		glTexCoord2f(0.0f,0.0f);	glVertex3f(-22.5f,0.1f,60.0f);
		glTexCoord2f(0.0f,32.0f);	glVertex3f(-22.5f,0.1f,-50.0f);
		glTexCoord2f(2.0f,32.0f);	glVertex3f(-17.5f,0.1f,-50.0f);
		glTexCoord2f(2.0f,0.0f);	glVertex3f(-17.5f,0.1f,60.0f);
		
		glTexCoord2f(0.0f,0.0f);	glVertex3f(-17.5f,0.1f,-17.5f);
		glTexCoord2f(0.0f,5.0f);	glVertex3f(-2.5f,0.1f,-17.5f);
		glTexCoord2f(2.0f,5.0f);	glVertex3f(-2.5f,0.1f,-22.5f);
		glTexCoord2f(2.0f,0.0f);	glVertex3f(-17.5f,0.1f,-22.5f);

		glTexCoord2f(0.0f,5.0f);	glVertex3f(-2.5f,0.1f,-22.5f);
		glTexCoord2f(2.0f,5.0f);	glVertex3f(2.5f,0.1f,-22.5f);
		glTexCoord2f(2.0f,0.0f);	glVertex3f(2.5f,0.1f,-2.5f);
		glTexCoord2f(0.0f,0.0f);	glVertex3f(-2.5f,0.1f,-2.5f);
		
		glTexCoord2f(0.0f,0.0f);	glVertex3f(-2.5f,0.1f,2.5f);
		glTexCoord2f(0.0f,27.0f);	glVertex3f(55.0f,0.1f,2.5f);
		glTexCoord2f(2.0f,27.0f);	glVertex3f(55.0f,0.1f,-2.5f);
		glTexCoord2f(2.0f,0.0f);	glVertex3f(-2.5f,0.1f,-2.5f);
		glEnd();

		glBindTexture(GL_TEXTURE_2D, 0);	// Unbind texture 
		delete []data;
		glDeleteTextures(1, &textureID_road);
		glDisable(GL_TEXTURE_2D);
	glEndList();
	//list 11 KEY_LEGEND
	glNewList(KEY_LEGEND,GL_COMPILE);
		short int width,height;
		width=glutGet(GLUT_WINDOW_WIDTH);
		height=glutGet(GLUT_WINDOW_HEIGHT);
		//1.
		glColor3f(1.0f,0.0f,0.0f);
		glRectf(0.06*width,0.14*height,0.10*width,0.18*height);
		glRectf(0.06*width,0.08*height,0.10*width,0.12*height);	
		//2.
		glColor3f(1.0f,1.0f,1.0f);
		glRectf(0.07*width,0.15*height,0.09*width,0.17*height);
		glRectf(0.07*width,0.09*height,0.09*width,0.11*height);
		//3.
		glColor3f(0.0f,0.0f,0.0f);
		write_text(0.06*width,0.2*height,"KEY:");
		write_text(0.11*width,0.15*height,"OBJECTIVE COMPLETE");
		write_text(0.11*width,0.09*height,"OBJECTIVE INCOMPLETE");
		//4.
		glColor3f(1.0f,0.0f,0.0f);
		glLineWidth(3);
		glBegin(GL_LINES);
			glVertex2f(0.07*width,0.15*height);
			glVertex2f(0.09*width,0.17*height);
			glVertex2f(0.07*width,0.17*height);
			glVertex2f(0.09*width,0.15*height);
		glEnd();
	glEndList();
	//list 12 CHARACTER
	glNewList(CHARACTER,GL_COMPILE);
		//render torso
		glPushMatrix();
			glTranslatef(0.0f,3.01f,0.0f);
			glScalef(2.0f,2.58f,2.0f);
			glutSolidCube(1);
		glPopMatrix();
		glColor3f(1.000f, 0.714f, 0.757f);//SKIN TONE
		//render face
		glPushMatrix();
			glTranslatef(0.0f,4.65f,0.0f);
			glScalef(1.0f,1.0f,1.5f);
			glutSolidCube(1);
		glPopMatrix();
		//render legs
		//left
		glPushMatrix();
			glTranslatef(-0.8f,0.9675f,0.0f);
			glScalef(0.4f,1.505f,1.5f);
			glutSolidCube(1);
		glPopMatrix();
		//right
		glPushMatrix();
			glTranslatef(0.8f,0.9675f,0.0f);
			glScalef(0.4f,1.505f,1.5f);
			glutSolidCube(1);
		glPopMatrix();
		//render hands
		//left
		glPushMatrix();
			glTranslatef(-1.2f,3.2475f,0.0f);
			glScalef(0.4f,1.505f,1.5f);
			glutSolidCube(1);
		glPopMatrix();
		//right
		glPushMatrix();
			glTranslatef(1.2f,3.2475f,0.0f);
			glScalef(0.4f,1.505f,1.5f);
			glutSolidCube(1);
		glPopMatrix();
		//render Shoes
		//left
		glColor3f(0.0f,0.0f,0.0f);//SHOE TONE
		glPushMatrix();
			glTranslatef(-0.9f,0.1075f,0.0f);
			glScalef(0.6f,0.35f,1.5f);
			glutSolidCube(1);
		glPopMatrix();
		//right
		glPushMatrix();
			glTranslatef(0.9f,0.1075f,0.0f);
			glScalef(0.6f,0.35f,1.5f);
			glutSolidCube(1);
		glPopMatrix();
		//render hair
		glPushMatrix();
			glTranslatef(0.0f,5.25f,0.0f);
			glScalef(1.0f,0.20f,1.5f);
			glutSolidCube(1);
		glPopMatrix();
		//render belt
		glColor3f(0.0f,0.0f,0.0f);
		glPushMatrix();
			glTranslatef(0.0f,2.6f,0.0f);
			glScalef(2.2f,0.2f,2.2f);
			glutSolidCube(1);
		glPopMatrix();
		//render eyes
		glPointSize(3);
		glBegin(GL_POINTS);
			glVertex3f(-0.35f,5.0f,0.77f);
			glVertex3f(0.35f,5.0f,0.77f);
		glEnd();
		//render mouth
		glLineWidth(1);
		glBegin(GL_LINES);
			glVertex3f(-0.35f,4.5f,0.77f);
			glVertex3f(0.35f,4.5f,0.77f);
		glEnd();
		//render belt buckle
		glColor3f(1.000f, 0.843f, 0.000f);
		glPushMatrix();
			glTranslatef(0.0f,2.6f,0.0f);
			glScalef(0.4f,0.4f,2.5f);
			glutSolidCube(1);
		glPopMatrix();
		glEndList();
//LEVEL 1
	//list SINGLE_MESH
	glNewList(MESH_SINGLE,GL_COMPILE);
		float y,z;
		glVertexPointer(3,GL_FLOAT,0,mesh_pole);
		glColor3f(0.827f, 0.827f, 0.827f);
		glDrawElements(GL_QUADS,24,GL_UNSIGNED_BYTE,cubeIndices);
		glLineWidth(3);
		for(y=0.35f;y<=3.5f;y+=0.35f)
		{
			glBegin(GL_LINES);
				glVertex3f(0.25f,y,0.5f);
				glVertex3f(0.25f,y,10.5f);
			glEnd();
		}
		for(z=1.0f;z<=10.50f;z+=0.5f)
		{
			glBegin(GL_LINES);
				glVertex3f(0.25f,0.2f,z);
				glVertex3f(0.25f,3.5f,z);
			glEnd();
		}
	glEndList();
	//list FENCE
	glNewList(FENCE,GL_COMPILE);
		//1st 0degree  rotation
		glPushMatrix();
			glTranslatef(30.0f,0.0f,-50.0f);
			glCallList(MESH_SINGLE);
			for(int i=0;i<3;i++)
			{
				glTranslatef(0.0f,0.0f,10.5f);
				glCallList(MESH_SINGLE);
			}
		glPopMatrix();
		//2nd 270degree rotation
		glPushMatrix();
			glTranslatef(50.0f,0.0f,29.0f);
			glRotatef(270.0f,0.0f,1.0f,0.0f);
			glCallList(MESH_SINGLE);
			glTranslatef(0.0f,0.0f,9.5f);
			glCallList(MESH_SINGLE);
		glPopMatrix();
		//3rd 180degree rotation
		glPushMatrix();
			glTranslatef(30.0f,0.0f,29.5f);
			glRotatef(180.0f,0.0f,1.0f,0.0f);
			glCallList(MESH_SINGLE);
			glTranslatef(0.0f,0.0f,10.5f);
			glCallList(MESH_SINGLE);
		glPopMatrix();
	glEndList();
	//LIST DISPLAY 2 HEDGES
	glNewList(HEDGE_MULTIPLE_1,GL_COMPILE);
		glPushMatrix();
			glTranslatef(-40.0f,0.0f,-20.0f);
			glScalef(1.0f,0.5f,0.8f);
			glCallList(HEDGE_SINGLE);
		glPopMatrix();
		glPushMatrix();
			glTranslatef(-10.0f,0.0f,30.0f);
			glScalef(2.2f,0.5f,0.8f);
			glCallList(HEDGE_SINGLE);	//display HEDGE
		glPopMatrix();
	glEndList();
	//LIST DISPLAY HOUSE
	glNewList(HOUSE,GL_COMPILE);
		//Base
		glColor3f(0.992f, 0.961f, 0.902f);
		glPushMatrix();
			glTranslatef(42.0f,3.5f,-40.0f);
			glScalef(12.0f,6.0f,20.0f);
			glutSolidCube(1);
		glPopMatrix();
		//house top
		glColor3f(0.871f, 0.722f, 0.529f);
		GLUquadricObj *quadratic_1;
		quadratic_1 = gluNewQuadric();
		glPushMatrix();
			glTranslatef(42.0f,6.5f,-40.0f);
			glRotatef(-90.0f, 1.0f, 0.0f, 0.0f);
			gluCylinder(quadratic_1,12.0,0,4.0f,32,32);
		glPopMatrix();
		//door
		glColor3f(0.627f, 0.322f, 0.176f);
		glBegin(GL_QUADS);
			glVertex3f(43.0f,0.5f,-29.9f);
			glVertex3f(43.0f,4.5f,-29.9f);
			glVertex3f(47.0f,4.5f,-29.9f);
			glVertex3f(47.0f,0.5f,-29.9f);
		glEnd();
		//Window
		glColor3f(0.184f, 0.310f, 0.310f);
		glBegin(GL_QUADS);
			glVertex3f(37.0f,3.5f,-29.9f);
			glVertex3f(37.0f,5.5f,-29.9f);
			glVertex3f(41.0f,5.5f,-29.9f);
			glVertex3f(41.0f,3.5f,-29.9f);
		glEnd();
	glEndList();
//LEVEL 2
	
}
void InitDisplayListsLevel1()
{
	//list NODES_1
	glNewList(NODES_1,GL_COMPILE);
		short int i,j,res;
		//NODES
		glColor3f(0.824f, 0.412f, 0.118f);
		glPointSize(10);
		glBegin(GL_POINTS);	
		for(i=0;i<18;i++)
			glVertex3fv(map_vertices_1[i]);
		glEnd();
		//NODE LINES
		glColor3f(1.000f, 0.843f, 0.000f);
		glLineWidth(3.0);
		for(i=0;i<obj.MAX_NODES;i++)
			for(j=0;j<4;j++)
				if((res=move_array[i][j]) != 0)
				{
					res-=1;				//resultant state,decremented as it is an index into map_vertices 
					glBegin(GL_LINES);
						glVertex3fv(map_vertices_1[i]);
						glVertex3fv(map_vertices_1[res]);
					glEnd();
				}
	glEndList();
}
void InitDisplayListsLevel2()
{
	//LIST NODES
	glNewList(NODES_2,GL_COMPILE);
		glColor3f(0.824f, 0.412f, 0.118f);
		glPointSize(10);
		//DRAW NODES
		glBegin(GL_POINTS);	
		for(int i=0;i<23;i++)
			glVertex3fv(map_vertices_2[i]);
		glEnd();
		//DRAW NODE LINES
		int res1;
		glColor3f(1.000f, 0.843f, 0.000f);
		glLineWidth(3.0);
		for(int i=0;i<obj.MAX_NODES;i++)
			for(int j=0;j<4;j++)
				if((res1=move_array[i][j]) != 0)
				{
					res1-=1;				//resultant state,decremented as it is an index into map_vertices 
					glBegin(GL_LINES);
						glVertex3fv(map_vertices_2[i]);
						glVertex3fv(map_vertices_2[res1]);
					glEnd();
				}
	glEndList();
}
void processSpecialKeys(int key, int xx, int yy)
{
	float fraction = 0.1f;
	if(Screen == LEVEL1 || Screen == LEVEL2)	// process only if level 1/2 is active
		switch (key) 
		{
			case GLUT_KEY_LEFT :
				angle -= 0.01f;
				lx = sin(angle);
				lz = -cos(angle);
				break;
			case GLUT_KEY_RIGHT :
				angle += 0.01f;
				lx = sin(angle);
				lz = -cos(angle);
				break;
			case GLUT_KEY_UP :
				x = x + (lx *12 * fraction);
				z =z+ (lz *12* fraction);
				break;
			case GLUT_KEY_DOWN :
				x =x- (lx *12* fraction);
				z =z- (lz *12* fraction);
				break;
		}	
}
int main(int argc, char* argv[])
{
	// Initialize GLUT
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);
	
	glutInitWindowSize(glutGet(GLUT_SCREEN_WIDTH),glutGet(GLUT_SCREEN_HEIGHT));
	//glutInitWindowSize(1280,720);
	glutCreateWindow("Hello, GL");
	init();
	glutFullScreen();
	glEnableClientState(GL_VERTEX_ARRAY);
	InitDisplayLists();
	glutReshapeFunc(changeViewPort);
	//cutscene();
	glutDisplayFunc(render);
	glutIdleFunc(render);
	glutKeyboardFunc(mykeyboard);
	glutSpecialFunc(processSpecialKeys);
	glutMouseFunc(mymouse);
	
	// Very important!  This initializes the entry points in the OpenGL driver so we can 
	// call all the functions in the API.
	GLenum err = glewInit();
	if (GLEW_OK != err) {
		fprintf(stderr, "GLEW error");
		return 1;
	}
	glEnable(GL_DEPTH_TEST);
	glEnable (GL_BLEND);
	
	glEnable (GL_LINE_SMOOTH);
	glEnable(GL_POLYGON_SMOOTH);	
	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glHint (GL_LINE_SMOOTH_HINT, GL_NICEST);
	glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
	
	glutMainLoop();
	return 0;
}